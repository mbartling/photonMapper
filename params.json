{
  "name": "Spatially Hashed Photon Mapper",
  "tagline": "Look a photon up: Michael Bartling (@mbartling), Souparna Purohit (@limac246)",
  "body": "### Introduction\r\n![Wine Glass Photon Map](https://raw.githubusercontent.com/mbartling/photonMapper/master/Results/wineglass1_photonMap.bmp)\r\nPhoton mapping is a powerful tool \r\n\r\n### Photon Mapping Basics\r\nPhoton mapping is achieved via a two pass algorithm. The first stage actually computes the **photon map** by firing photons from each light source into the scene in much the same way as traditional ray tracing fires rays from the camera into the scene. The photons are stored in some data structure for later aggregation. Effectively, the second pass is a traditional ray tracer where the shading model incorporates cumulative photon intensities in some local neighborhood. \r\n\r\nIn Jensen's original photon mapping method, the photons are stored in a balanced axis aligned KD-tree and keep track of photon intensity, intersection positions, angle of incidence, and other metadata for future aggregation. During the second pass of the algorithm, when a ray intersects an object all photons in a local sphere are aggregated and the radius of the sphere increases until a predefined energy condition is met. Consequently, total number of photons launched into the scene, photon intensities, minimum sphere radius, maximum sphere radius, and minimum total energy are all hyper-parameters to tune.   \r\n\r\n### Our Architecture\r\nRather than computing aggregating the photons in the second pass, we opt to aggregate them in the first pass using a spatial hash. By predefining a bucket size (or sphere radius), we can trade spatial precision and accuracy for speed. In fact, this method achieves O(1) photon map access time. Furthermore, we no longer have to worry about the near neighbor search since this information is encoded directly into the data structure. In the second pass, we compute the raytraced image and photon map image simultaneously, but save their values into different buffers. Since we use a spatial hash, our photon map image is rather speckled, so we apply a gaussian blur before screen blending it with the raytraced image.  \r\n\r\n#### Creation of Spatial Hash (Pre - Raytracing)\r\n\r\n```\r\nfirePhotons():\r\n\tFor each light source:\r\n\t\temit n photons towards the bounding boxes of each object (this step can be parallelized)\r\n\t\ttracePhoton(depth)\r\n\r\ntracePhoton(depth):\r\n\tif (photon intersects scene object AND object is closest object):\r\n\t\tif surface not reflective and not refractive: \r\n\t\t\tabsorb photon (see 3)\r\n\t\tif surface reflective: \r\n\t\t\tif absorbPhoton( 1 - kr ): \r\n\t\t\t\treturn\r\n\t\t\telse if not absorbed:\r\n\t\t\t\treflect photon\r\n\t\t\t\ttracePhoton(depth-1)\r\n\t\tif surface is transmissive:\r\n\t\t\tif absorbPhoton( 1 - kt ): \r\n\t\t\t\treturn\r\n\t\t\telse f not absorbed:\r\n\t\t\t\trefract photon\r\n\t\t\t\ttracePhoton(depth-1)\r\n\r\n//(The above method uses Russian Roulette. Since no new photon is created, energy is conserved.)\r\n// Absorb photon with probability p\r\nabsorbPhoton(p):\r\n\tif(rand() < p):\r\n\t\tphotonMap[IntersectionPoint] += photon\r\n\t\treturn true\r\n\telse:\r\n\t\treturn false\r\n```\r\nBy this point, we have the flux at each position of the spatial hash. \r\n\r\n#### Creation of the Photon Buffer (During Raytracing)\r\n\t\r\n```\r\nPhotonColor = alpha * ImageColor + (1 - alpha) * photonMap[IntersectionPoint].flux \r\n```\r\n### Ray Tracer Features\r\n* Path Tracing / distribution ray tracing\r\n* Jittered sampling\r\n* Up to 16x super sampling\r\n* Templated KD-tree acceleration using SAH \r\n* Interpolated textures\r\n* Cube Maps\r\n* OBJ loading\r\n* Photon Mapping\r\n* Configurable number of photons and photon energy\r\n* Point lights and Directional lights fully supported\r\n  * **Note**: Photons only fired towards extents of objects.\r\n* Basic Image enhancement API (Gaussian kernels, Sobel operators, mean filters, etc)\r\n\r\n### Pretty Pictures\r\n\r\n#### Color Bleeding Example\r\n![Easy 3a](https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/out_easy.bmp)\r\n![Easy 3a Photon Map](https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/out_easy_photonMap.bmp.bmp)\r\n![Easy 3a Final](https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/out_easy_Final.bmp.bmp)\r\n\r\n#### Caustics Example\r\n![Simple Sphere](https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/simple_sphere_orig.bmp)\r\n![Simple Sphere Photon Map](https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/simple_sphere_photon.bmp)\r\n![Simple Sphere Final](https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/simple_sphere_ultimate.bmp)\r\n\r\n#### Other Cool Examples\r\n![Ray Trace](https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/refl_2_orig.bmp)\r\n![Photon Map](https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/refl_2_photon.bmp)\r\n![Final](https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/refl_2_ultimate.bmp)\r\n### Authors and Contributors\r\nMichael Bartling (@mbartling), Souparna Purohit (@limac246)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}