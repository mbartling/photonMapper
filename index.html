<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Spatially Hashed Photon Mapper by mbartling</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Spatially Hashed Photon Mapper</h1>
      <h2 class="project-tagline">Look a photon up: Michael Bartling (@mbartling), Souparna Purohit (@limac246)</h2>
      <a href="https://github.com/mbartling/photonMapper" class="btn">View on GitHub</a>
      <a href="https://github.com/mbartling/photonMapper/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/mbartling/photonMapper/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h3>

<p>Final project for CS384G Spring 2016 at the University of Texas at Austin</p>

<p><img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/outWineglassPM.bmp" alt="Wine Glass Photon Map"></p>

<p>One of the problems faced in traditional ray tracing is global illumination. Though a certain degree of global illumination can be acheived in the traditional method (for instance, reflection, refraction, shadows), other effects such as caustics and diffuse-color-bleeding are not. Photon Mapping, a technique developed by Henrik Wann Jensen, resolves these issues. Whereas traditional ray tracing only accounts for the observer's perspective in the shading model, photon mapping incorporates both the observer's and the lights' perspectives. As such, effects that are easy to compute from the perspective of the light, such as caustics, and effects that are easy to compute from the user's perspective, such as specular reflections, and refractions, are all incorporated in the photon mapping shading model. </p>

<p>In this blog post, we outline a basic overview of Photon Mapping, and present our implementation of it, along with a discussion of how our implementation differs from that in most literature. We also include some of the output images from our algorithm, separated out into three buffers: the first depicting the original (ray-traced) rendered, the second with the photon map, and the third depicting a screen overlay blending of the first two buffers. </p>

<h3>
<a id="photon-mapping-basics" class="anchor" href="#photon-mapping-basics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Photon Mapping Basics</h3>

<p>Photon mapping is achieved via a two pass algorithm. The first stage actually computes the <strong>photon map</strong> by firing photons from each light source into the scene in much the same way as traditional ray tracing fires rays from the camera into the scene. The photons are stored in some data structure for later aggregation. Effectively, the second pass is a traditional ray tracer where the shading model incorporates cumulative photon intensities in some local neighborhood. </p>

<p>In Jensen's original photon mapping method, the photons are stored in a balanced axis aligned KD-tree and keep track of photon intensity, intersection positions, angle of incidence, and other metadata for future aggregation. During the second pass of the algorithm, when a ray intersects an object all photons in a local sphere are aggregated and the radius of the sphere increases until a predefined energy condition is met. Consequently, total number of photons launched into the scene, photon intensities, minimum sphere radius, maximum sphere radius, and minimum total energy are all hyper-parameters to tune.   </p>

<h3>
<a id="our-architecture" class="anchor" href="#our-architecture" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Our Architecture</h3>

<p>Rather than computing aggregating the photons in the second pass, we opt to aggregate them in the first pass using a spatial hash. By predefining a bucket size (or sphere radius), we can trade spatial precision and accuracy for speed. In fact, this method achieves O(1) photon map access time. Furthermore, we no longer have to worry about the near neighbor search since this information is encoded directly into the data structure. In the second pass, we compute the raytraced image and photon map image simultaneously, but save their values into different buffers. Since we use a spatial hash, our photon map image is rather speckled, so we apply a gaussian blur before screen blending it with the raytraced image.  </p>

<h4>
<a id="creation-of-spatial-hash-pre---raytracing" class="anchor" href="#creation-of-spatial-hash-pre---raytracing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creation of Spatial Hash (Pre - Raytracing)</h4>

<pre><code>firePhotons():
    For each light source:
        emit n photons towards the bounding boxes of each object (this step can be parallelized)
        tracePhoton(depth)

tracePhoton(depth):
    if (photon intersects scene object AND object is closest object):
        if surface not reflective and not refractive: 
            absorb photon (see 3)
        if surface reflective: 
            if absorbPhoton( 1 - kr ): 
                return
            else if not absorbed:
                reflect photon
                tracePhoton(depth-1)
        if surface is transmissive:
            if absorbPhoton( 1 - kt ): 
                return
            else f not absorbed:
                refract photon
                tracePhoton(depth-1)

//(The above method uses Russian Roulette. Since no new photon is created, energy is conserved.)
// Absorb photon with probability p
absorbPhoton(p):
    if(rand() &lt; p):
        photonMap[IntersectionPoint] += photon
        return true
    else:
        return false
</code></pre>

<p>By this point, we have the flux at each position of the spatial hash. </p>

<h4>
<a id="creation-of-the-photon-buffer-during-raytracing" class="anchor" href="#creation-of-the-photon-buffer-during-raytracing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creation of the Photon Buffer (During Raytracing)</h4>

<pre><code>PhotonColor = alpha * ImageColor + (1 - alpha) * photonMap[IntersectionPoint].flux 
</code></pre>

<h3>
<a id="ray-tracer-features" class="anchor" href="#ray-tracer-features" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ray Tracer Features</h3>

<ul>
<li>Path Tracing / distribution ray tracing</li>
<li>Jittered sampling</li>
<li>Up to 16x super sampling</li>
<li>Templated KD-tree acceleration using SAH </li>
<li>Interpolated textures</li>
<li>Cube Maps</li>
<li>OBJ loading</li>
<li>Photon Mapping</li>
<li>Configurable number of photons and photon energy</li>
<li>Point lights and Directional lights fully supported

<ul>
<li>
<strong>Note</strong>: Photons only fired towards extents of objects.</li>
</ul>
</li>
<li>Basic Image enhancement API (Gaussian kernels, Sobel operators, mean filters, etc)</li>
</ul>

<h3>
<a id="pretty-pictures" class="anchor" href="#pretty-pictures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pretty Pictures</h3>

<h4>
<a id="color-bleeding-example" class="anchor" href="#color-bleeding-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Color Bleeding Example</h4>

<p><img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/out_easy.bmp" alt="Easy 3a">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/out_easy_photonMap.bmp.bmp" alt="Easy 3a Photon Map">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/out_easy_Final.bmp.bmp" alt="Easy 3a Final"></p>

<h4>
<a id="caustics-example" class="anchor" href="#caustics-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Caustics Example</h4>

<p><img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/simple_sphere_orig.bmp" alt="Simple Sphere">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/simple_sphere_photon.bmp" alt="Simple Sphere Photon Map">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/simple_sphere_ultimate.bmp" alt="Simple Sphere Final"></p>

<h4>
<a id="other-cool-examples" class="anchor" href="#other-cool-examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Other Cool Examples</h4>

<p><img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/refl_2_orig.bmp" alt="Ray Trace">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/refl_2_photon.bmp" alt="Photon Map">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/refl_2_ultimate.bmp" alt="Final"></p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p><img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/outWineglass.bmp" alt="Ray Trace">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/outWineglassPM.bmp" alt="Photon Map">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/outWineglassFinal.bmp" alt="Final"></p>

<h3>
<a id="authors-and-contributors-1" class="anchor" href="#authors-and-contributors-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>Michael Bartling (<a href="https://github.com/mbartling" class="user-mention">@mbartling</a>), Souparna Purohit (<a href="https://github.com/limac246" class="user-mention">@limac246</a>)</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/mbartling/photonMapper">Spatially Hashed Photon Mapper</a> is maintained by <a href="https://github.com/mbartling">mbartling</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
