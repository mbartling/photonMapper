<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Spatially Hashed Photon Mapper by mbartling</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Spatially Hashed Photon Mapper</h1>
      <h2 class="project-tagline">Look a photon up: Michael Bartling (@mbartling), Souparna Purohit (@limac246)</h2>
      <a href="https://github.com/mbartling/photonMapper" class="btn">View on GitHub</a>
      <a href="https://github.com/mbartling/photonMapper/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/mbartling/photonMapper/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h3>

<p><img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/Results/wineglass1_photonMap.bmp" alt="Wine Glass Photon Map">
Photon mapping is a powerful tool </p>

<h3>
<a id="photon-mapping-basics" class="anchor" href="#photon-mapping-basics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Photon Mapping Basics</h3>

<p>Photon mapping is achieved via a two pass algorithm. The first stage actually computes the <strong>photon map</strong> by firing photons from each light source into the scene in much the same way as traditional ray tracing fires rays from the camera into the scene. The photons are stored in some data structure for later aggregation. Effectively, the second pass is a traditional ray tracer where the shading model incorporates cumulative photon intensities in some local neighborhood. </p>

<p>In Jensen's original photon mapping method, the photons are stored in a balanced axis aligned KD-tree and keep track of photon intensity, intersection positions, angle of incidence, and other metadata for future aggregation. During the second pass of the algorithm, when a ray intersects an object all photons in a local sphere are aggregated and the radius of the sphere increases until a predefined energy condition is met. Consequently, total number of photons launched into the scene, photon intensities, minimum sphere radius, maximum sphere radius, and minimum total energy are all hyper-parameters to tune.   </p>

<h3>
<a id="our-architecture" class="anchor" href="#our-architecture" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Our Architecture</h3>

<p>Rather than computing aggregating the photons in the second pass, we opt to aggregate them in the first pass using a spatial hash. By predefining a bucket size (or sphere radius), we can trade spatial precision and accuracy for speed. In fact, this method achieves O(1) photon map access time. Furthermore, we no longer have to worry about the near neighbor search since this information is encoded directly into the data structure. In the second pass, we compute the raytraced image and photon map image simultaneously, but save their values into different buffers. Since we use a spatial hash, our photon map image is rather speckled, so we apply a gaussian blur before screen blending it with the raytraced image.  </p>

<h4>
<a id="creation-of-spatial-hash-pre---raytracing" class="anchor" href="#creation-of-spatial-hash-pre---raytracing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creation of Spatial Hash (Pre - Raytracing)</h4>

<pre><code>firePhotons():
    For each light source:
        emit n photons towards the bounding boxes of each object (this step can be parallelized)
        tracePhoton(depth)

tracePhoton(depth):
    if (photon intersects scene object AND object is closest object):
        if surface not reflective and not refractive: 
            absorb photon (see 3)
        if surface reflective: 
            if absorbPhoton( 1 - kr ): 
                return
            else if not absorbed:
                reflect photon
                tracePhoton(depth-1)
        if surface is transmissive:
            if absorbPhoton( 1 - kt ): 
                return
            else f not absorbed:
                refract photon
                tracePhoton(depth-1)

//(The above method uses Russian Roulette. Since no new photon is created, energy is conserved.)
// Absorb photon with probability p
absorbPhoton(p):
    if(rand() &lt; p):
        photonMap[IntersectionPoint] += photon
        return true
    else:
        return false
</code></pre>

<p>By this point, we have the flux at each position of the spatial hash. </p>

<h4>
<a id="creation-of-the-photon-buffer-during-raytracing" class="anchor" href="#creation-of-the-photon-buffer-during-raytracing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creation of the Photon Buffer (During Raytracing)</h4>

<pre><code>PhotonColor = alpha * ImageColor + (1 - alpha) * photonMap[IntersectionPoint].flux 
</code></pre>

<h3>
<a id="pretty-pictures" class="anchor" href="#pretty-pictures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pretty Pictures</h3>

<h4>
<a id="color-bleeding-example" class="anchor" href="#color-bleeding-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Color Bleeding Example</h4>

<p><img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/out_easy.bmp" alt="Easy 3a">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/out_easy_photonMap.bmp.bmp" alt="Easy 3a Photon Map">
<img src="https://raw.githubusercontent.com/mbartling/photonMapper/master/FinalResults/out_easy_Final.bmp.bmp" alt="Easy 3a Final"></p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>Michael Bartling (<a href="https://github.com/mbartling" class="user-mention">@mbartling</a>), Souparna Purohit (<a href="https://github.com/limac246" class="user-mention">@limac246</a>)</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/mbartling/photonMapper">Spatially Hashed Photon Mapper</a> is maintained by <a href="https://github.com/mbartling">mbartling</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
